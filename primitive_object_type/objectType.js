// 객체(참조)타입 값의 특성

// 1. 변경가능한 값
// 객체를 할당한 변수가 기억하는 메모리 공간에 접근하면 참조값(생선된 객체가 저장된 메모리 공간의 주소 그 자체)에 접근할 수 있다.

// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
let person = {
    name: 'Lee'
};

// person 변수에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.
console.log(person); // {name: "lee"}



// 객체를 할당한 변수는 재할당 없이 객체를 직접 변경(프로퍼티 추가, 프로퍼티 값 갱신, 프로퍼티 삭제 등)할 수 있다.
// 프로퍼티 값 갱신
person.name = 'kim';

// 프로퍼티 동적 생성
person.address = 'seoul';

console.log(person); // {name: 'kim', address: 'seoul'}

// 객체는 변경가능 한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다.
// 이 때 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.



// 얕은 복사와 깊은 복사

// 객체를 프로퍼티 값으로 갖는 객체의 경우 
const o = {x: {y: 1} };

//얕은 복사 :한 단계 까지만 복사
const c1 = {...o}; // 스프레드 문법. c1 변수에 o 객체를 복사함.
console.log( c1 === o ); // false
console.log(c1.x === o.x); // true

// ------------------------------------------ 다른 예제
const obj = { 
    string: 'hi'
}; // ex. A라는 메모리 공간에 저장됨

const obj2 = {
    string: 'hi'
}; // ex. B라는 메모리 공간에 저장됨

console.log( obj === obj2 ); // false ( A !== B /두 변수에 저장된 것은 객체를 참조하는 주소값인데, 그 주소값은 서로 다름)
console.log( obj.string === obj2.string); // true (({string: 'hi'} === {string: 'hi}) /객체 값은 같음)
// ------------------------------------------ 


// 깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사
// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash');

const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false

// 얕은 복사와 깊은 복사로 생성된 객체는 원본과 다른 객체다. (원본과 복사본은 참조값이 다른 별개의 객체)
// 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사
// 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만듦


// 원시값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있다.
const v = 1;

// 깊은 복사라고 부르기도 한다.
const copy1 = v;
console.log(copy1 === v); // true (원시값 복사)

const g = {x : 1};

// 얕은 복사라도 부르기도 한다.
const copy2 = g;
console.log(copy2 === g); // true (참조값 복사)



// 2. 참조에 의한 전달
// 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 *참조 값*이 복사되어 전달된다.

let person = {
    name: 'Lee'
};
// 참조 값을 복사(얕은 복사)
let copy = person;

/* 

- 특정 메모리 공간에 객체가 할당된다.
- person 변수에는 객체가 할당된 *메모리 공간의 주소값*이 할당된다. (객체 자체가 담기는 것이 아님!)
- copy 변수에 person 변수를 할당하게 되면 copy 변수에도 객체가 할당된 메모리 공간의 주소값이 할당된다.
- 즉 두 변수는 하나의 객체에 접근할 수 있고 공유할 수 있다.
- 따라서 원본(person) 또는 사본(copy) 중 어느 한쪽에서 객체를 수정하면 서로 영향을 주고 받는다.
*/

copy.name = 'kim'; // copy를 통해 객체 변경 (프로퍼티 값 수정)
person.address = 'Seoul'; //person을 통해 객체 변경 (프로퍼티 추가)

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: 'kim', address: 'Seoul'}
console.log(copy); // {name: 'kim', address: 'Seoul'}


// 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.
// 엄밀히 말하자면 자바스크립트에서는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만 존재한다고 볼 수 있다.
// 원시 값 복사 시: 같은 원시값 복사 
// 참조 값 복사 시: 메모리주소값 복사

